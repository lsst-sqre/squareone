name: Dependabot Auto-Merge

# This workflow automatically enables auto-merge for Dependabot PRs that:
# 1. Pass CI (test job completion)
# 2. Have a changeset file
# 3. Are not major version updates
#
# Security: Uses workflow_run trigger to run in the context of the default
# branch, avoiding "pwn request" vulnerabilities. Verifies PR author before
# taking any actions.

on:
  workflow_run:
    workflows: [CI]
    types: [completed]

# Minimal permissions for security
permissions:
  contents: read
  pull-requests: write

jobs:
  auto-merge:
    runs-on: ubuntu-latest
    # Only run if CI succeeded and was triggered by a pull_request event
    if: >
      github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.event == 'pull_request'


    steps:
      # Get PR information from the workflow run
      - name: Get PR number
        id: pr
        uses: actions/github-script@v8
        with:
          script: |
            const pullRequests = context.payload.workflow_run.pull_requests;
            if (!pullRequests || pullRequests.length === 0) {
              console.log('No pull requests found for this workflow run');
              return null;
            }

            const pr = pullRequests[0];
            console.log(`Found PR #${pr.number}`);

            return {
              number: pr.number,
              html_url: pr.html_url,
              head_sha: pr.head.sha,
              head_ref: pr.head.ref
            };

      # Security: Verify PR is from Dependabot
      # We fetch the full PR details using the GitHub API to access the author information,
      # as the workflow_run payload's pull_requests array contains simplified PR objects
      # that don't include the user property.
      - name: Verify Dependabot PR
        if: steps.pr.outputs.result != 'null'
        id: verify
        uses: actions/github-script@v8
        with:
          script: |
            const prNumber = JSON.parse('${{ steps.pr.outputs.result }}').number;
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });

            console.log(`PR author: ${pr.user.login}`);

            if (pr.user.login !== 'dependabot[bot]') {
              console.log('Not a Dependabot PR, skipping');
              core.setOutput('is_dependabot', 'false');
              return;
            }

            core.setOutput('is_dependabot', 'true');

      # Extract Dependabot metadata for semver analysis
      # We can't use dependabot/fetch-metadata action because it requires pull_request
      # context, but we're running in workflow_run context for security reasons.
      # Instead, we parse the PR title and commits to determine update type.
      - name: Get Dependabot metadata
        if: steps.verify.outputs.is_dependabot == 'true'
        id: metadata
        uses: actions/github-script@v8
        with:
          script: |
            const prNumber = JSON.parse('${{ steps.pr.outputs.result }}').number;

            // Fetch PR details
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });

            console.log(`PR title: ${pr.title}`);

            // Parse PR title for dependency information
            // Formats:
            // - "Bump package from 1.0.0 to 2.0.0"
            // - "Bump package from 1.0.0 to 2.0.0 in /path"
            // - "Bump the group-name group with X updates" (grouped updates)
            // - "Bump the group-name group across 1 directory with X updates"

            let updateType = 'version-update:semver-patch';
            let dependencyNames = '';

            // Check for grouped updates
            const groupMatch = pr.title.match(/Bump the (.+) group/);
            if (groupMatch) {
              dependencyNames = `${groupMatch[1]} group`;

              // For grouped updates, we need to check commits to determine if any are major
              const { data: commits } = await github.rest.pulls.listCommits({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });

              // Check all commits for version changes
              let hasMajor = false;
              let hasMinor = false;

              for (const commit of commits) {
                const message = commit.commit.message;
                const bumpMatch = message.match(/Bump .+ from ([\d.]+) to ([\d.]+)/);

                if (bumpMatch) {
                  const [, oldVersion, newVersion] = bumpMatch;
                  const type = determineUpdateType(oldVersion, newVersion);

                  if (type === 'major') {
                    hasMajor = true;
                    break;
                  } else if (type === 'minor') {
                    hasMinor = true;
                  }
                }
              }

              if (hasMajor) {
                updateType = 'version-update:semver-major';
              } else if (hasMinor) {
                updateType = 'version-update:semver-minor';
              } else {
                updateType = 'version-update:semver-patch';
              }
            } else {
              // Single dependency update
              const bumpMatch = pr.title.match(/Bump (.+?) from ([\d.]+) to ([\d.]+)/);

              if (bumpMatch) {
                const [, packageName, oldVersion, newVersion] = bumpMatch;
                dependencyNames = packageName;

                const type = determineUpdateType(oldVersion, newVersion);
                updateType = `version-update:semver-${type}`;
              } else {
                console.log('Could not parse Dependabot PR title format');
                dependencyNames = 'unknown';
              }
            }

            function determineUpdateType(oldVersion, newVersion) {
              const oldParts = oldVersion.split('.').map(v => parseInt(v) || 0);
              const newParts = newVersion.split('.').map(v => parseInt(v) || 0);

              // Compare major version
              if (newParts[0] > oldParts[0]) {
                return 'major';
              }

              // Compare minor version
              if (newParts[1] > oldParts[1]) {
                return 'minor';
              }

              // Otherwise it's a patch
              return 'patch';
            }

            console.log(`Dependency names: ${dependencyNames}`);
            console.log(`Update type: ${updateType}`);

            core.setOutput('dependency-names', dependencyNames);
            core.setOutput('update-type', updateType);

            return {
              dependency_names: dependencyNames,
              update_type: updateType
            };

      # Check if PR has changeset files
      # The dependabot-changesets.yaml workflow should have already created these
      - name: Check for changeset
        if: steps.verify.outputs.is_dependabot == 'true'
        id: changeset
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ fromJson(steps.pr.outputs.result).number }}
        run: |
          echo "Checking for changeset files in PR #$PR_NUMBER"

          # Get list of changed files
          FILES=$(gh pr view "$PR_NUMBER" --repo "${{ github.repository }}" --json files --jq '.files[].path')

          echo "Changed files:"
          echo "$FILES"

          # Check if any file is in .changeset/ directory
          if echo "$FILES" | grep -q '^\.changeset/.*\.md$'; then
            echo "âœ“ Changeset found"
            echo "has_changeset=true" >> $GITHUB_OUTPUT
          else
            echo "âœ— No changeset found"
            echo "has_changeset=false" >> $GITHUB_OUTPUT
          fi

      # Enable auto-merge if all conditions are met:
      # 1. PR is from Dependabot (verified above)
      # 2. Not a major version update
      # 3. Has a changeset file
      - name: Enable auto-merge with squash
        if: >
          steps.verify.outputs.is_dependabot == 'true' && steps.metadata.outputs.update-type != 'version-update:semver-major' && steps.changeset.outputs.has_changeset == 'true'


        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_URL: ${{ fromJson(steps.pr.outputs.result).html_url }}
          UPDATE_TYPE: ${{ steps.metadata.outputs.update-type }}
        run: |
          echo "Enabling auto-merge for $UPDATE_TYPE update"
          gh pr merge --auto --squash "$PR_URL" --repo "${{ github.repository }}"

      # Add comment for visibility
      - name: Comment on PR
        if: >
          steps.verify.outputs.is_dependabot == 'true' && steps.metadata.outputs.update-type != 'version-update:semver-major' && steps.changeset.outputs.has_changeset == 'true'


        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ fromJson(steps.pr.outputs.result).number }}
          UPDATE_TYPE: ${{ steps.metadata.outputs.update-type }}
          DEPENDENCY_NAMES: ${{ steps.metadata.outputs.dependency-names }}
        run: |
          gh pr comment "$PR_NUMBER" --repo "${{ github.repository }}" --body \
            "ðŸ¤– **Auto-merge enabled**

            This Dependabot PR has been configured for auto-merge with squash strategy:
            - âœ… CI passed
            - âœ… Changeset detected
            - âœ… Update type: \`$UPDATE_TYPE\`
            - ðŸ“¦ Dependencies: $DEPENDENCY_NAMES

            The PR will automatically merge once all branch protection requirements are satisfied."

      # Log when auto-merge is skipped
      - name: Log skip reason
        if: >
          steps.verify.outputs.is_dependabot == 'true' && (steps.metadata.outputs.update-type == 'version-update:semver-major' ||
           steps.changeset.outputs.has_changeset != 'true')


        env:
          UPDATE_TYPE: ${{ steps.metadata.outputs.update-type }}
          HAS_CHANGESET: ${{ steps.changeset.outputs.has_changeset }}
        run: |
          echo "Auto-merge skipped:"
          echo "  Update type: $UPDATE_TYPE"
          echo "  Has changeset: $HAS_CHANGESET"

          if [ "$UPDATE_TYPE" = "version-update:semver-major" ]; then
            echo "  Reason: Major version updates require manual review"
          fi

          if [ "$HAS_CHANGESET" != "true" ]; then
            echo "  Reason: No changeset file found (may still be generating)"
          fi
